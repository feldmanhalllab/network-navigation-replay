---
title: "Behavioral analyses"
output:
  html_document:
    code_download: true
    code_folding: hide
    toc: true
    toc_float:
      collapsed: true
---

# Setup

```{r libraries}
workflow_name <- "netnav_07_behavioral_analyses"

library(tidyverse)
library(here)
library(patchwork)

library(glmmTMB)
library(broom.mixed)

source(here("code", "utils", "ggplot_themes.R"))
source(here("code", "utils", "kable_utils.R"))
source(here("code", "utils", "unicode_greek.R"))

knitting <- knitr::is_html_output()

create_path <- function(this_path) {
  if (!dir.exists(this_path)) {
    dir.create(this_path, recursive = TRUE)
  }
}

predict_glmmTMB <- function(make_predictions_for, model_object) {
  make_predictions_for %>%
    bind_cols(
      predict(
        object = model_object,
        newdata = .,
        re.form = NA, allow.new.levels = TRUE, se.fit = TRUE, type = "response"
      )
    )
}

check_significance <- function(tidy_df) {
  tidy_df %>%
    mutate(
      sig = case_when(
        p.value < 0.001 ~ "***",
        p.value < 0.01 ~ "**",
        p.value < 0.05 ~ "*",
        p.value < 0.1 ~ ".",
        TRUE ~ ""
      )
    )
}

if (knitting) {
  here("outputs", workflow_name) %>%
    create_path()
}
```

```{r load-data}
mem_study1 <- here("data", "clean_data", "study1_memory.csv") %>%
  read_csv(show_col_types = FALSE) %>%
  mutate(study = "Study 1", measurement_id = str_c("D", measurement_id)) %>%
  filter(from != to)

mem_study2 <- here("data", "clean_data", "study2_memory.csv") %>%
  read_csv(show_col_types = FALSE) %>%
  mutate(study = "Study 2", measurement_id = str_c("D", measurement_id)) %>%
  filter(from != to)

mem_study3 <- here("data", "clean_data", "study3_memory.csv") %>%
  read_csv(show_col_types = FALSE) %>%
  mutate(
    study = "Study 3",
    measurement_id = case_when(
      measurement_id == 1 ~ "D1",
      measurement_id == 2 ~ "D1b",
      measurement_id == 3 ~ "D2"
    )
  ) %>%
  filter(from != to)

params <- here("data", "param_fits", "clean_params", "clean_param_fits.csv") %>%
  read_csv(show_col_types = FALSE)

nav_study1 <- here("data", "clean_data", "study1_message_passing.csv") %>%
  read_csv(show_col_types = FALSE) %>%
  filter(
    two_correct_options == FALSE,
    shortest_path_given_opts == shortest_path_given_start_end
  ) %>%
  mutate(
    study = "Study 1",
    measurement_id = str_c("D", measurement_id),
    shortest_path = factor(shortest_path_given_opts)
  ) %>%
  select(
    study, sub_id, measurement_id, shortest_path,
    startpoint_id, endpoint_id,
    opt1_id, opt2_id,
    correct_choice, sub_choice,
    correct, rt
  )

nav_study2 <- here("data", "clean_data", "study2_message_passing.csv") %>%
  read_csv(show_col_types = FALSE) %>%
  filter(
    two_correct_options == FALSE,
    shortest_path_given_opts == shortest_path_given_start_end
  ) %>%
  mutate(
    study = "Study 2",
    measurement_id = case_when(
      network == "learned" ~ str_c("D", measurement_id),
      network == "reevaluated" ~ "D2b"
    ),
    shortest_path = factor(shortest_path_given_opts)
  ) %>%
  select(
    study, sub_id, measurement_id, shortest_path,
    startpoint_id, endpoint_id,
    opt1_id, opt2_id,
    correct_choice, sub_choice,
    correct, rt
  ) %>%
  filter(measurement_id %in% c("D1", "D2"))

nav_study3 <- here("data", "clean_data", "study3_message_passing.csv") %>%
  read_csv(show_col_types = FALSE) %>%
  filter(
    two_correct_options == FALSE,
    shortest_path_given_opts == shortest_path_given_start_end
  ) %>%
  mutate(
    study = "Study 3",
    measurement_id = case_when(
      network == "reevaluated" ~ "D2b",
      measurement_id == 1 ~ "D1",
      measurement_id == 2 ~ "D1b",
      measurement_id == 3 ~ "D2"
    ),
    shortest_path = factor(shortest_path_given_opts)
  ) %>%
  select(
    study, sub_id, measurement_id, shortest_path,
    startpoint_id, endpoint_id,
    opt1_id, opt2_id,
    correct_choice, sub_choice,
    correct, rt
  ) %>%
  filter(measurement_id %in% c("D1", "D1b", "D2"))
```


# Memory accuracy

We'll start with descriptive statistics of memory accuracy.

```{r descriptive-memory-day1}
bind_rows(mem_study1, mem_study2, mem_study3) %>%
  group_by(study, measurement_id) %>%
  summarise(accuracy = mean(correct), .groups = "drop") %>%
  kable_custom("Descriptive: Memory accuracy", digits = 2)
```

## Study 1

We'll start with study 1. Since this is a one-day study, we're only interested in testing memory accuracy against chance (50%).

```{r memory-study1}
mem_study1 %>%
  glmmTMB(
    correct ~ 1 + (1 | sub_id),
    family = binomial,
    data = .
  ) %>%
  tidy(conf.int = TRUE) %>%
  check_significance() %>%
  select(-c(effect, component)) %>%
  kable_custom("Memory: Study 1", digits = 3)
```

## Study 2

Study 2 was a two-day study, so we'll test how accuracy changes after overnight rest.

```{r memory-study2}
mem_study2 %>%
  glmmTMB(
    correct ~ measurement_id + (1 | sub_id),
    family = binomial,
    data = .
  ) %>%
  tidy(conf.int = TRUE) %>%
  check_significance() %>%
  select(-c(effect, component)) %>%
  kable_custom("Memory: Study 2", digits = 3)
```

## Study 3

For the primary analysis of interest, we can analyze study 3 just like we analyzed study 2.

```{r memory-study3-overnight}
mem_study3 %>%
  filter(measurement_id %in% c("D1", "D2")) %>%
  glmmTMB(
    correct ~ measurement_id + (1 | sub_id),
    family = binomial,
    data = .
  ) %>%
  tidy(conf.int = TRUE) %>%
  check_significance() %>%
  select(-c(effect, component)) %>%
  kable_custom(c("Memory: Study 3", "Overnight rest"), digits = 3)
```

Study 3 also included an awake rest condition at the end of Day 1. We'll make "after awake rest" the reference category and compare it against the other measurements (before/after overnight rest).

```{r memory-study3-awake}
mem_study3 %>%
  mutate(measurement_id = fct_relevel(measurement_id, "D1b")) %>%
  glmmTMB(
    correct ~ measurement_id + (1 | sub_id),
    family = binomial,
    data = .
  ) %>%
  tidy(conf.int = TRUE) %>%
  check_significance() %>%
  select(-c(effect, component)) %>%
  kable_custom(c("Memory: Study 3", "Awake rest"), digits = 3)
```


# Social navigation

Note that in this section, we're looking at results from aggregated/pooled data. Disaggregated results from each study are reported later in this notebook.

## Before rest

In the paper, we start by examining social navigation behaviors in a one-day session (Study 1), or in the first session of a two-day study (Studies 2-3). Across all three studies, the procedure is exactly identical; studies 2-3 are, in this part of the dataset, exact replications of study 1.

We'll start off with some descriptive statistics of human behavior. To maximize statistical power, we will pool across studies whenever possible.

```{r descriptive-navigation-day1}
bind_rows(nav_study1, nav_study2, nav_study3) %>%
  filter(measurement_id == "D1") %>%
  group_by(measurement_id, shortest_path) %>%
  summarise(accuracy = mean(correct), .groups = "drop") %>%
  arrange(measurement_id, shortest_path) %>%
  pivot_wider(
    names_from = shortest_path, values_from = accuracy, names_prefix = "dist-"
  ) %>%
  kable_custom("Descriptive: Navigation accuracy", digits = 2)
```

And now the inferential statistical tests. Note that we're interested in knowing whether navigation accuracy differs from chance at each distance, so we'll estimate the same statistical model multiple times, changing the reference category each time. Note that this only reparameterizes the model, such that the *same* variance is accounted for by different parameters; it does *not* change the total amount of variance accounted for.

```{r stats-day1}
nav_day1 <- bind_rows(nav_study1, nav_study2, nav_study3) %>%
  filter(measurement_id == "D1") %>%
  # Give every subject a distinct identifier
  mutate(sub_id = str_c(study, " s", sub_id))

stats_nav_day1_dist2 <- nav_day1 %>%
  mutate(shortest_path = fct_relevel(shortest_path, "2")) %>%
  glmmTMB(
    correct ~ shortest_path + (1 + shortest_path | sub_id) + (1 | study),
    family = binomial,
    data = .
  )

stats_nav_day1_dist3 <- nav_day1 %>%
  mutate(shortest_path = fct_relevel(shortest_path, "3")) %>%
  glmmTMB(
    correct ~ shortest_path + (1 + shortest_path | sub_id) + (1 | study),
    family = binomial,
    data = .
  )

stats_nav_day1_dist4 <- nav_day1 %>%
  mutate(shortest_path = fct_relevel(shortest_path, "4")) %>%
  glmmTMB(
    correct ~ shortest_path + (1 + shortest_path | sub_id) + (1 | study),
    family = binomial,
    data = .
  )

map_dfr(
  .x = list(
    "dist-2" = stats_nav_day1_dist2,
    "dist-3" = stats_nav_day1_dist3,
    "dist-4" = stats_nav_day1_dist4
  ),
  .f = ~tidy(.x, conf.int = TRUE),
  .id = "ref_cat"
) %>%
  check_significance() %>%
  select(-c(effect, component)) %>%
  kable_custom(
    "Navigation accuracy: Day 1 (before rest)",
    grouping_var = ref_cat
  )
```

We'll plot out the raw data, plus model predictions...

```{r plot-day1}
predict_nav_day1 <- expand_grid(
  measurement_id = "D1",
  shortest_path = factor(2:4),
  sub_id = NA, study = NA
) %>%
  predict_glmmTMB(stats_nav_day1_dist2)

plot_nav_day1 <- nav_day1 %>%
  group_by(sub_id, shortest_path) %>%
  summarise(accuracy = mean(correct), .groups = "drop") %>%
  ggplot(aes(x=shortest_path, y=accuracy)) +
  theme_custom() +
  geom_hline(yintercept = 0.5, linetype = "dashed") +
  geom_dotplot(
    binwidth = 0.01,
    binaxis = "y", stackdir = "center",
    position = position_dodge(width = 0.75),
    dotsize = 1, alpha = 0.5, color = NA,
    show.legend = FALSE
  ) +
  geom_pointrange(
    aes(x = shortest_path, y = fit, ymin = fit - se.fit, ymax = fit + se.fit),
    data = predict_nav_day1, inherit.aes = FALSE, show.legend = FALSE,
    position = position_dodge(width = 0.15), linewidth = 1
  ) +
  geom_line(
    aes(x = shortest_path, y = fit, group = measurement_id),
    data = predict_nav_day1, inherit.aes = FALSE,
    position = position_dodge(width = 0.15), linewidth = 1
  ) +
  scale_x_discrete(name = "Shortest path distance") +
  scale_y_continuous(
    name = "Accuracy", labels = scales::percent, breaks = seq(0, 1, 0.25)
  ) +
  coord_cartesian(ylim = c(0.2, 1.1)) +
  theme(legend.position = "bottom") +
  ggtitle("Human social navigation")

plot_nav_day1

if (knitting) {
  ggsave(
    here("outputs", workflow_name, str_c("navigation_before_rest", ".pdf")),
    plot = plot_nav_day1,
    width = 6, height = 4,
    units = "in", dpi = 300
  )
}
```


# After rest: Does navigation improve?

First, some descriptives...

```{r descriptive-navigation-all}
bind_rows(nav_study2, nav_study3) %>%
  filter(measurement_id %in% c("D1", "D2")) %>%
  group_by(measurement_id, shortest_path) %>%
  summarise(accuracy = mean(correct), .groups = "drop") %>%
  arrange(measurement_id, shortest_path) %>%
  pivot_wider(
    names_from = shortest_path, values_from = accuracy, names_prefix = "dist-"
  ) %>%
  kable_custom("Descriptive: Navigation accuracy", digits = 2)

nav_study3 %>%
  group_by(measurement_id, shortest_path) %>%
  summarise(accuracy = mean(correct), .groups = "drop") %>%
  arrange(measurement_id, shortest_path) %>%
  pivot_wider(
    names_from = shortest_path, values_from = accuracy, names_prefix = "dist-"
  ) %>%
  kable_custom(
    c("Descriptive: Navigation accuracy", "(Study 3 only)"), digits = 2
  )
```

## Overnight rest

In the mixed-effects logistic regression, we're pooling across studies 2-3 (study 1 was only a one-day experiment).

```{r stats-day1-to-day2}
nav_day1_to_day2 <- bind_rows(nav_study2, nav_study3) %>%
  filter(measurement_id %in% c("D1", "D2")) %>%
  # Give every subject a distinct identifier
  mutate(sub_id = str_c(study, " s", sub_id))

stats_nav_day2_dist2 <- nav_day1_to_day2 %>%
  mutate(shortest_path = fct_relevel(shortest_path, "2")) %>%
  glmmTMB(
    correct ~ shortest_path * measurement_id +
      (1 + shortest_path + measurement_id | sub_id) + (1 | study),
    family = binomial,
    data = .
  )

stats_nav_day2_dist3 <- nav_day1_to_day2 %>%
  mutate(shortest_path = fct_relevel(shortest_path, "3")) %>%
  glmmTMB(
    correct ~ shortest_path * measurement_id +
      (1 + shortest_path + measurement_id | sub_id) + (1 | study),
    family = binomial,
    data = .
  )

stats_nav_day2_dist4 <- nav_day1_to_day2 %>%
  mutate(shortest_path = fct_relevel(shortest_path, "4")) %>%
  glmmTMB(
    correct ~ shortest_path * measurement_id +
      (1 + shortest_path + measurement_id | sub_id) + (1 | study),
    family = binomial,
    data = .
  )

map_dfr(
  .x = list(
    "dist-2" = stats_nav_day2_dist2,
    "dist-3" = stats_nav_day2_dist3,
    "dist-4" = stats_nav_day2_dist4
  ),
  .f = ~tidy(.x, conf.int = TRUE),
  .id = "ref_cat"
) %>%
  check_significance() %>%
  select(-c(effect, component)) %>%
  kable_custom(
    "Navigation accuracy: Day 1 to Day 2",
    grouping_var = ref_cat, digits = 3
  )
```

```{r plot-day1-to-day2}
predict_nav_day1_to_day2 <- expand_grid(
  measurement_id = c("D1", "D2"),
  shortest_path = factor(2:4),
  sub_id = NA, study = NA
) %>%
  predict_glmmTMB(stats_nav_day2_dist2)

plot_nav_day1_to_day2 <- nav_day1_to_day2 %>%
  group_by(sub_id, measurement_id, shortest_path) %>%
  summarise(accuracy = mean(correct), .groups = "drop") %>%
  ggplot(aes(x=shortest_path, y=accuracy, color=measurement_id)) +
  theme_custom() +
  geom_hline(yintercept = 0.5, linetype = "dashed") +
  geom_dotplot(
    aes(fill = measurement_id),
    binwidth = 0.01,
    binaxis = "y", stackdir = "center",
    position = position_dodge(width = 0.75),
    dotsize = 1, alpha = 0.5, color = NA,
    show.legend = FALSE
  ) +
  geom_pointrange(
    aes(
      x = shortest_path, y = fit,
      ymin = fit - se.fit, ymax = fit + se.fit,
      color = measurement_id
    ),
    data = predict_nav_day1_to_day2, inherit.aes = FALSE, show.legend = FALSE,
    position = position_dodge(width = 0.15), linewidth = 1
  ) +
  geom_line(
    aes(
      x = shortest_path, y = fit,
      group = measurement_id, color = measurement_id
    ),
    data = predict_nav_day1_to_day2, inherit.aes = FALSE,
    position = position_dodge(width = 0.15), linewidth = 1
  ) +
  scale_x_discrete(name = "Shortest path distance") +
  scale_y_continuous(
    name = "Accuracy", labels = scales::percent, breaks = seq(0, 1, 0.25)
  ) +
  scale_color_manual(
    name = "Measurement",
    values = c("D1"="#fa9fb5", "D2"="#7a0177"),
    labels = c("D1"="Before rest", "D2"="After overnight rest")
  ) +
  scale_fill_manual(values = c("D1"="#fa9fb5", "D2"="#7a0177")) +
  coord_cartesian(ylim = c(0.25, 1.1)) +
  theme(legend.position = "bottom") +
  ggtitle("Navigation after overnight rest")

plot_nav_day1_to_day2

if (knitting) {
  ggsave(
    here("outputs", workflow_name, str_c("navigation_overnight_rest", ".pdf")),
    plot = plot_nav_day1_to_day2,
    width = 6, height = 4,
    units = "in", dpi = 300
  )
}
```

## Awake rest

Is a brief period of awake rest sufficient for improving navigation accuracy?

```{r stats-awake-rest}
stats_nav_awake_dist2 <- nav_study3 %>%
  filter(measurement_id %in% c("D1", "D1b")) %>%
  mutate(shortest_path = fct_relevel(shortest_path, "2")) %>%
  glmmTMB(
    correct ~ shortest_path * measurement_id +
      (1 + shortest_path + measurement_id | sub_id),
    family = binomial,
    data = .
  )

stats_nav_awake_dist3 <- nav_study3 %>%
  filter(measurement_id %in% c("D1", "D1b")) %>%
  mutate(shortest_path = fct_relevel(shortest_path, "3")) %>%
  glmmTMB(
    correct ~ shortest_path * measurement_id +
      (1 + shortest_path + measurement_id | sub_id),
    family = binomial,
    data = .
  )

stats_nav_awake_dist4 <- nav_study3 %>%
  filter(measurement_id %in% c("D1", "D1b")) %>%
  mutate(shortest_path = fct_relevel(shortest_path, "4")) %>%
  glmmTMB(
    correct ~ shortest_path * measurement_id +
      (1 + shortest_path + measurement_id | sub_id),
    family = binomial,
    data = .
  )

map_dfr(
  .x = list(
    "dist-2" = stats_nav_awake_dist2,
    "dist-3" = stats_nav_awake_dist3,
    "dist-4" = stats_nav_awake_dist4
  ),
  .f = ~tidy(.x, conf.int = TRUE),
  .id = "ref_cat"
) %>%
  check_significance() %>%
  select(-c(effect, component)) %>%
  kable_custom(
    "Navigation accuracy: Awake Rest",
    grouping_var = ref_cat, digits = 3
  )
```

```{r plot-awake-rest}
predict_nav_awake <- expand_grid(
  measurement_id = c("D1", "D1b"),
  shortest_path = factor(2:4),
  sub_id = NA, study = NA
) %>%
  predict_glmmTMB(stats_nav_awake_dist2)

plot_nav_awake <- nav_study3 %>%
  filter(measurement_id %in% c("D1", "D1b")) %>%
  group_by(sub_id, measurement_id, shortest_path) %>%
  summarise(accuracy = mean(correct), .groups = "drop") %>%
  ggplot(aes(x=shortest_path, y=accuracy, color=measurement_id)) +
  theme_custom() +
  geom_hline(yintercept = 0.5, linetype = "dashed") +
  geom_dotplot(
    aes(fill = measurement_id),
    binwidth = 0.01,
    binaxis = "y", stackdir = "center",
    position = position_dodge(width = 0.75),
    dotsize = 1, alpha = 0.5, color = NA,
    show.legend = FALSE
  ) +
  geom_pointrange(
    aes(
      x = shortest_path, y = fit,
      ymin = fit - se.fit, ymax = fit + se.fit,
      color = measurement_id
    ),
    data = predict_nav_awake, inherit.aes = FALSE, show.legend = FALSE,
    position = position_dodge(width = 0.15), linewidth = 1
  ) +
  geom_line(
    aes(
      x = shortest_path, y = fit,
      group = measurement_id, color = measurement_id
    ),
    data = predict_nav_awake, inherit.aes = FALSE,
    position = position_dodge(width = 0.15), linewidth = 1
  ) +
  scale_x_discrete(name = "Shortest path distance") +
  scale_y_continuous(
    name = "Accuracy", labels = scales::percent, breaks = seq(0, 1, 0.25)
  ) +
  scale_color_manual(
    name = "Measurement",
    values = c("D1"="#fa9fb5", "D1b"="#2c7fb8"),
    labels = c("D1"="Before rest", "D1b"="After awake rest")
  ) +
  scale_fill_manual(values = c("D1"="#fa9fb5", "D1b"="#2c7fb8")) +
  coord_cartesian(ylim = c(0.25, 1.1)) +
  theme(legend.position = "bottom") +
  ggtitle("Navigation after awake rest")

plot_nav_awake

if (knitting) {
  ggsave(
    here("outputs", workflow_name, str_c("navigation_awake_rest", ".pdf")),
    plot = plot_nav_awake,
    width = 6, height = 4,
    units = "in", dpi = 300
  )
}
```


# Relating behavior to model parameters

Does estimated gamma significantly increase after overnight rest?

```{r create-dfs-for-analysis}
changes_in_gamma <- params %>%
  filter(
    study %in% c("Study 2", "Study 3"),
    measurement_id %in% c("D1", "D2"),
    model == "sr_analytic",
    param_name == "sr_gamma"
  ) %>%
  select(study, sub_id, measurement_id, sr_gamma = param_value) %>%
  mutate(lookahead = 1/(1-sr_gamma)) %>%
  arrange(study, sub_id, measurement_id) %>%
  group_by(study, sub_id) %>%
  mutate(
    delta_gamma = sr_gamma - first(sr_gamma),
    delta_lookahead = lookahead - first(lookahead)
  ) %>%
  ungroup()

changes_in_behavior <- bind_rows(nav_study2, nav_study3) %>%
  filter(measurement_id %in% c("D1", "D2")) %>%
  group_by(study, sub_id, measurement_id, shortest_path) %>%
  summarise(accuracy = mean(correct), .groups = "drop") %>%
  arrange(study, sub_id, shortest_path, measurement_id) %>%
  group_by(study, sub_id, shortest_path) %>%
  mutate(delta_accuracy = accuracy - first(accuracy)) %>%
  ungroup()
```

```{r stats-gamma-increase}
changes_in_gamma %>%
  group_by(measurement_id) %>%
  summarise(
    median_gamma = median(sr_gamma),
    median_lookahead = median(lookahead)
  ) %>%
  kable_custom("Median SR gamma before/after overnight rest", digits = 3)

changes_in_gamma %>%
  select(study, sub_id, measurement_id, sr_gamma) %>%
  pivot_wider(names_from = measurement_id, values_from = sr_gamma) %>%
  with(
    wilcox.test(
      D2, D1, alternative = "greater", paired = TRUE, conf.int = TRUE
    )
  ) %>%
  tidy() %>%
  kable_custom("Increase in SR gamma after overnight rest", digits = 3)

changes_in_gamma %>%
  select(study, sub_id, measurement_id, lookahead) %>%
  pivot_wider(names_from = measurement_id, values_from = lookahead) %>%
  with(
    wilcox.test(
      D2, D1, alternative = "greater", paired = TRUE, conf.int = TRUE
    )
  ) %>%
  tidy() %>%
  kable_custom("Increase in SR lookahead after overnight rest", digits = 3)
```

```{r plot-gamma-increase}
plot_gamma_change <- changes_in_gamma %>%
  select(study, sub_id, measurement_id, sr_gamma) %>%
  ggplot(aes(x=measurement_id, y=sr_gamma)) +
  theme_custom() +
  geom_line(aes(group = interaction(study, sub_id)), alpha = 0.1) +
  stat_summary(
    aes(group = 1), geom = "line", fun = median, linewidth = 1
  ) +
  scale_x_discrete(
    name = "Measurement",
    labels = c("D1"="Before rest", "D2"="After overnight rest")
  ) +
  scale_y_continuous(
    name = str_c("Estimated ", unicode_greek["gamma"]),
    breaks = seq(0, 1, 0.25)
  ) +
  coord_cartesian(ylim = c(0, 1.1)) +
  theme(legend.position = "bottom") +
  ggtitle(
    str_c(
      unicode_greek["Delta"], unicode_greek["gamma"], " after overnight rest"
    )
  )

plot_gamma_change

if (knitting) {
  ggsave(
    here("outputs", workflow_name, str_c("gamma_change", ".pdf")),
    plot = plot_gamma_change,
    width = 6, height = 4,
    units = "in", dpi = 300,
    device = cairo_pdf
  )
}
```

Are changes in estimated gamma related to changes in navigation behaviors?

```{r stats-gamma-accuracy}
changes_in_behavior %>%
  filter(measurement_id == "D2") %>%
  left_join(
    changes_in_gamma %>%
      filter(measurement_id == "D2"),
    by = join_by(study, sub_id, measurement_id)
  ) %>%
  group_by(shortest_path) %>%
  nest() %>%
  mutate(
    test = map(
      .x = data,
      .f = ~with(
        .x,
        cor.test(
          delta_accuracy, delta_gamma,
          method = "spearman", exact = FALSE, alternative = "greater"
        )
      ) %>% tidy()
    )
  ) %>%
  unnest(test) %>%
  ungroup() %>%
  select(-data) %>%
  kable_custom("∆ Accuracy ~ ∆ SR gamma (after overnight rest)", digits = 3)
```

```{r plot-gamma-accuracy}
plot_gamma_accuracy_change <- changes_in_behavior %>%
  filter(measurement_id == "D2") %>%
  left_join(
    changes_in_gamma %>%
      filter(measurement_id == "D2"),
    by = join_by(study, sub_id, measurement_id)
  ) %>%
  ggplot(aes(x=delta_gamma, y=delta_accuracy, color=shortest_path)) +
  theme_custom() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  geom_point(alpha = 0.25, show.legend = FALSE) +
  geom_smooth(method = "lm", se = FALSE, linewidth = 1.5) +
  scale_x_continuous(name = str_c("Change in ", unicode_greek["gamma"])) +
  scale_y_continuous(name = "Change in accuracy") +
  scale_color_manual(
    name = "Shortest path distance",
    values = c("#88CCEE", "#CC6677", "#DDCC77")
  ) +
  coord_cartesian(xlim = c(-1, 1.1)) +
  theme(legend.position = "bottom") +
  ggtitle(
    str_c(
      unicode_greek["Delta"], "Navigation ~ ",
      unicode_greek["Delta"], unicode_greek["gamma"]
    )
  )

plot_gamma_accuracy_change

if (knitting) {
  ggsave(
    here("outputs", workflow_name, str_c("gamma_accuracy_change", ".pdf")),
    plot = plot_gamma_accuracy_change,
    width = 6, height = 4,
    units = "in", dpi = 300,
    device = cairo_pdf
  )
}
```


# Do people bring social priors into learning?

In principle, it's possible that subjects would have shown comparable "navigation" behaviors if they'd learned about a network of (e.g.) computers transmitting messages to each other. It'd be nice if we could find some evidence that subjects construed the task as being "social", so we'll see if there's evidence that people bring social priors about homophily into learning.

```{r load-learning-data}
adjlist <- here("data", "clean_data", "adjlist_learned.csv") %>%
  read_csv(show_col_types = FALSE)

nodes_study1 <- here("data", "clean_data", "study1_node_mappings.csv") %>%
  read_csv(show_col_types = FALSE)

nodes_study2 <- here("data", "clean_data", "study2_node_mappings.csv") %>%
  read_csv(show_col_types = FALSE)

nodes_study3 <- here("data", "clean_data", "study3_node_mappings.csv") %>%
  read_csv(show_col_types = FALSE)

learn_study1 <- here("data", "clean_data", "study1_learn.csv") %>%
  read_csv(show_col_types = FALSE) %>%
  mutate(
    block = case_when(
      trial <= 13 ~ 1,
      trial <= 13*2 ~ 2,
      trial <= 13*3 ~ 3,
      trial <= 13*4 ~ 4,
      trial <= 13*5 ~ 5,
      trial <= 13*6 ~ 6
    )
  ) %>%
  select(sub_id, block, from = target_id, to = guess_id, guess_correct)

learn_study2 <- here("data", "clean_data", "study2_learn.csv") %>%
  read_csv(show_col_types = FALSE) %>%
  mutate(
    block = case_when(
      trial <= 13 ~ 1,
      trial <= 13*2 ~ 2,
      trial <= 13*3 ~ 3,
      trial <= 13*4 ~ 4,
      trial <= 13*5 ~ 5,
      trial <= 13*6 ~ 6
    )
  ) %>%
  select(sub_id, block, from = target_id, to = guess_id, guess_correct)

learn_study3 <- here("data", "clean_data", "study3_learn.csv") %>%
  read_csv(show_col_types = FALSE) %>%
  mutate(
    block = case_when(
      trial <= 13 ~ 1,
      trial <= 13*2 ~ 2,
      trial <= 13*3 ~ 3,
      trial <= 13*4 ~ 4,
      trial <= 13*5 ~ 5,
      trial <= 13*6 ~ 6
    )
  ) %>%
  select(sub_id, block, from = target_id, to = guess_id, guess_correct)
```

```{r df-learning-with-nodes}
learn_study1_nodes <- expand_grid(
  sub_id = sort(unique(learn_study1$sub_id)),
  block = 1:6,
  from = 1:13,
  to = from
) %>%
  filter(from != to) %>%
  left_join(learn_study1) %>%
  mutate(guessed_friends = !is.na(guess_correct)) %>%
  select(-guess_correct) %>%
  left_join(adjlist, by = join_by(from, to)) %>%
  left_join(
    nodes_study1 %>%
      select(
        sub_id,
        from = node_id,
        from_race = node_race,
        from_gender = node_gender
      ),
    by = join_by(sub_id, from)
  ) %>%
  left_join(
    nodes_study1 %>%
      select(
        sub_id,
        to = node_id,
        to_race = node_race,
        to_gender = node_gender
      ),
    by = join_by(sub_id, to)
  )

learn_study2_nodes <- expand_grid(
  sub_id = sort(unique(learn_study2$sub_id)),
  block = 1:6,
  from = 1:13,
  to = from
) %>%
  filter(from != to) %>%
  left_join(learn_study2) %>%
  mutate(guessed_friends = !is.na(guess_correct)) %>%
  select(-guess_correct) %>%
  left_join(adjlist, by = join_by(from, to)) %>%
  left_join(
    nodes_study2 %>%
      select(
        sub_id,
        from = node_id,
        from_race = node_race,
        from_gender = node_gender
      ),
    by = join_by(sub_id, from)
  ) %>%
  left_join(
    nodes_study2 %>%
      select(
        sub_id,
        to = node_id,
        to_race = node_race,
        to_gender = node_gender
      ),
    by = join_by(sub_id, to)
  )

learn_study3_nodes <- expand_grid(
  sub_id = sort(unique(learn_study3$sub_id)),
  block = 1:6,
  from = 1:13,
  to = from
) %>%
  filter(from != to) %>%
  left_join(learn_study3) %>%
  mutate(guessed_friends = !is.na(guess_correct)) %>%
  select(-guess_correct) %>%
  left_join(adjlist, by = join_by(from, to)) %>%
  left_join(
    nodes_study3 %>%
      select(
        sub_id,
        from = node_id,
        from_race = node_race,
        from_gender = node_gender
      ),
    by = join_by(sub_id, from)
  ) %>%
  left_join(
    nodes_study3 %>%
      select(
        sub_id,
        to = node_id,
        to_race = node_race,
        to_gender = node_gender
      ),
    by = join_by(sub_id, to)
  )
```

In the mixed-effects logistic regression below, we're trying to predict whether a subject guessed that two network members were friends, given that those network members were same-race or same-gender. To make sure that these actually reflect subjects' priors, we'll only look at responses where the two network members were *not* actually friends. 

The learning task consisted of six blocks in total, where each block presented every network member as a Target. On each trial, subjects were presented with virtual flash cards. When shown a Target network member, participants were required to find all of the Target's friends from the face-down cards. When a card corresponding to the Target's friend was selected, the card flipped face-up to reveal their photograph. Cards remained face-down in response to incorrect guesses. To ensure that subjects were truly learning about friendships, rather than something low-level like the cards' spatial location, we shuffled where the cards were located in block four. Due to this task design, subjects were only able to guess randomly during blocks one and four, and we therefore excluded these blocks from our analysis.

```{r stats-social-priors}
bind_rows(
  learn_study1_nodes %>% mutate(study = 1),
  learn_study2_nodes %>% mutate(study = 2),
  learn_study3_nodes %>% mutate(study = 3),
) %>%
  # Homophily
  mutate(
    same_race = from_race == to_race,
    same_gender = from_gender == to_gender
  ) %>%
  # Only include blocks where the subject plausibly knew which face-down
  # flash cards were associated with which network member
  filter(block %in% c(2, 3, 5, 6)) %>%
  # Only look at pairs of network members who were NOT actually friends
  filter(edge == 0) %>%
  # Unique identifier for each subject, across studies
  mutate(sub_id = str_c("study", study, ", sub", sub_id)) %>%
  glmmTMB(
    guessed_friends ~ same_race + same_gender + (1 | sub_id) + (1 | study),
    family = binomial,
    data = .
  ) %>%
  tidy(conf.int = TRUE) %>%
  check_significance() %>%
  kable_custom("Learning task: Evidence of social priors", digits = 3)
```

To see how "sticky" these priors were, we can try looking *only* at the data from the last block. Even here, we see evidence that race and gender homophily influence subjects' learning.

```{r stats-social-priors-last-block}
bind_rows(
  learn_study1_nodes %>% mutate(study = 1),
  learn_study2_nodes %>% mutate(study = 2),
  learn_study3_nodes %>% mutate(study = 3),
) %>%
  # Homophily
  mutate(
    same_race = from_race == to_race,
    same_gender = from_gender == to_gender
  ) %>%
  # Only include the last block
  filter(block == 6) %>%
  # Only look at pairs of network members who were NOT actually friends
  filter(edge == 0) %>%
  # Unique identifier for each subject, across studies
  mutate(sub_id = str_c("study", study, ", sub", sub_id)) %>%
  glmmTMB(
    guessed_friends ~ same_race + same_gender + (1 | sub_id) + (1 | study),
    family = binomial,
    data = .
  ) %>%
  tidy(conf.int = TRUE) %>%
  check_significance() %>%
  kable_custom(
    c("Learning task: Evidence of social priors", "(Only last block)"),
    digits = 3
  )
```


# Social navigation, disaggregated

## Navigation before overnight rest

We want to know whether navigation accuracy is different from chance at each distance, so we'll iteratively reparameterize the model so that each distance is the reference category.

We'll start with study 1. Note that estimating a random slope leads to model convergence problems in studies 2-3, so we'll only be estimating a random intercept per subject.

```{r nav-day1-study1}
stats_nav_study1_dist2 <- nav_study1 %>%
  mutate(shortest_path = fct_relevel(shortest_path, "2")) %>%
  glmmTMB(
    correct ~ shortest_path + (1 | sub_id),
    family = binomial,
    data = .
  )

stats_nav_study1_dist3 <- nav_study1 %>%
  mutate(shortest_path = fct_relevel(shortest_path, "3")) %>%
  glmmTMB(
    correct ~ shortest_path + (1 | sub_id),
    family = binomial,
    data = .
  )

stats_nav_study1_dist4 <- nav_study1 %>%
  mutate(shortest_path = fct_relevel(shortest_path, "4")) %>%
  glmmTMB(
    correct ~ shortest_path + (1  | sub_id),
    family = binomial,
    data = .
  )

map_dfr(
  .x = list(
    "dist-2" = stats_nav_study1_dist2,
    "dist-3" = stats_nav_study1_dist3,
    "dist-4" = stats_nav_study1_dist4
  ),
  .f = ~tidy(.x, conf.int = TRUE),
  .id = "ref_cat"
) %>%
  check_significance() %>%
  select(-c(effect, component)) %>%
  kable_custom(
    "Navigation accuracy: Day 1, Study 1", grouping_var = ref_cat, digits = 3
  )
```

Moving on to study 2:

```{r nav-day1-study2}
stats_nav_study2_day1_dist2 <- nav_study2 %>%
  filter(measurement_id == "D1") %>%
  mutate(shortest_path = fct_relevel(shortest_path, "2")) %>%
  glmmTMB(
    correct ~ shortest_path + (1 | sub_id),
    family = binomial,
    data = .
  )

stats_nav_study2_day1_dist3 <- nav_study2 %>%
  filter(measurement_id == "D1") %>%
  mutate(shortest_path = fct_relevel(shortest_path, "3")) %>%
  glmmTMB(
    correct ~ shortest_path + (1 | sub_id),
    family = binomial,
    data = .
  )

stats_nav_study2_day1_dist4 <- nav_study2 %>%
  filter(measurement_id == "D1") %>%
  mutate(shortest_path = fct_relevel(shortest_path, "4")) %>%
  glmmTMB(
    correct ~ shortest_path + (1 | sub_id),
    family = binomial,
    data = .
  )

map_dfr(
  .x = list(
    "dist-2" = stats_nav_study2_day1_dist2,
    "dist-3" = stats_nav_study2_day1_dist3,
    "dist-4" = stats_nav_study2_day1_dist4
  ),
  .f = ~tidy(.x, conf.int = TRUE),
  .id = "ref_cat"
) %>%
  check_significance() %>%
  select(-c(effect, component)) %>%
  kable_custom(
    "Navigation accuracy: Day 1, Study 2", grouping_var = ref_cat, digits = 3
  )
```

And finally study 3:

```{r nav-day1-study3}
stats_nav_study3_day1_dist2 <- nav_study3 %>%
  filter(measurement_id == "D1") %>%
  mutate(shortest_path = fct_relevel(shortest_path, "2")) %>%
  glmmTMB(
    correct ~ shortest_path + (1 | sub_id),
    family = binomial,
    data = .
  )

stats_nav_study3_day1_dist3 <- nav_study3 %>%
  filter(measurement_id == "D1") %>%
  mutate(shortest_path = fct_relevel(shortest_path, "3")) %>%
  glmmTMB(
    correct ~ shortest_path + (1 | sub_id),
    family = binomial,
    data = .
  )

stats_nav_study3_day1_dist4 <- nav_study3 %>%
  filter(measurement_id == "D1") %>%
  mutate(shortest_path = fct_relevel(shortest_path, "4")) %>%
  glmmTMB(
    correct ~ shortest_path + (1 | sub_id),
    family = binomial,
    data = .
  )

map_dfr(
  .x = list(
    "dist-2" = stats_nav_study3_day1_dist2,
    "dist-3" = stats_nav_study3_day1_dist3,
    "dist-4" = stats_nav_study3_day1_dist4
  ),
  .f = ~tidy(.x, conf.int = TRUE),
  .id = "ref_cat"
) %>%
  check_significance() %>%
  select(-c(effect, component)) %>%
  kable_custom(
    "Navigation accuracy: Day 1, Study 3", grouping_var = ref_cat, digits = 3
  )
```


## Navigation after overnight rest

In studies 2-3, subjects returned to the lab after overnight rest. The primary analysis of interest is to test whether there is evidence of navigation accuracy increasing. Because we're interested in addressing this question for each distance, we'll be iteratively reparameterizing the models so that each distance is the reference category.

```{r nav-day2-study2}
stats_nav_study2_day2_dist2 <- nav_study2 %>%
  filter(measurement_id %in% c("D1", "D2")) %>%
  mutate(shortest_path = fct_relevel(shortest_path, "2")) %>%
  glmmTMB(
    correct ~ measurement_id * shortest_path + (1 + measurement_id | sub_id),
    family = binomial,
    data = .
  )

stats_nav_study2_day2_dist3 <- nav_study2 %>%
  filter(measurement_id %in% c("D1", "D2")) %>%
  mutate(shortest_path = fct_relevel(shortest_path, "3")) %>%
  glmmTMB(
    correct ~ measurement_id * shortest_path + (1 + measurement_id | sub_id),
    family = binomial,
    data = .
  )

stats_nav_study2_day2_dist4 <- nav_study2 %>%
  filter(measurement_id %in% c("D1", "D2")) %>%
  mutate(shortest_path = fct_relevel(shortest_path, "4")) %>%
  glmmTMB(
    correct ~ measurement_id * shortest_path + (1 + measurement_id | sub_id),
    family = binomial,
    data = .
  )

map_dfr(
  .x = list(
    "dist-2" = stats_nav_study2_day2_dist2,
    "dist-3" = stats_nav_study2_day2_dist3,
    "dist-4" = stats_nav_study2_day2_dist4
  ),
  .f = ~tidy(.x, conf.int = TRUE),
  .id = "ref_cat"
) %>%
  check_significance() %>%
  select(-c(effect, component)) %>%
  kable_custom(
    "Navigation accuracy: Day 2, Study 2", grouping_var = ref_cat, digits = 3
  )
```

We'll do the same for study 3.

```{r nav-day2-study3}
stats_nav_study3_day2_dist2 <- nav_study3 %>%
  filter(measurement_id %in% c("D1", "D2")) %>%
  mutate(shortest_path = fct_relevel(shortest_path, "2")) %>%
  glmmTMB(
    correct ~ measurement_id * shortest_path + (1 + measurement_id | sub_id),
    family = binomial,
    data = .
  )

stats_nav_study3_day2_dist3 <- nav_study3 %>%
  filter(measurement_id %in% c("D1", "D2")) %>%
  mutate(shortest_path = fct_relevel(shortest_path, "3")) %>%
  glmmTMB(
    correct ~ measurement_id * shortest_path + (1 + measurement_id | sub_id),
    family = binomial,
    data = .
  )

stats_nav_study3_day2_dist4 <- nav_study3 %>%
  filter(measurement_id %in% c("D1", "D2")) %>%
  mutate(shortest_path = fct_relevel(shortest_path, "4")) %>%
  glmmTMB(
    correct ~ measurement_id * shortest_path + (1 + measurement_id | sub_id),
    family = binomial,
    data = .
  )

map_dfr(
  .x = list(
    "dist-2" = stats_nav_study3_day2_dist2,
    "dist-3" = stats_nav_study3_day2_dist3,
    "dist-4" = stats_nav_study3_day2_dist4
  ),
  .f = ~tidy(.x, conf.int = TRUE),
  .id = "ref_cat"
) %>%
  check_significance() %>%
  select(-c(effect, component)) %>%
  kable_custom(
    "Navigation accuracy: Day 2, Study 3", grouping_var = ref_cat, digits = 3
  )
```

